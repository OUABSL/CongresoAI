



§ GRAPH QUERY FRAMEWORK



In graph pattern matching, precise definitions are fundamental for research. They create a shared terminology, whilst theorems illustrated by mathematical proofs reveal essential characteristics and direct the development of algorithms. This paper presents a mathematical tool for conducting graph pattern matching. We will do this by utilising these mathematical tools.

We are exploring graph queries that enable atomic specialisations. We aim to produce pattern specialisations that select only a particular subset of elements by utilising a set of elements that satisfy a specific relational pattern. Selection Graphs serves as an instance of this query tool and has been developed for use in relational learning procedures. However, it has a fundamental limitation, as its patterns are unable to include cycles. Furthermore, when dealing with high relational data, incorporating a graphical representation of SQL queries can lead to efficiency issues. Our proposal draws inspiration from this method while bypassing its possible constraints. 

When searching for query specialization, we aim to also create complementary queries to cover new conditions. Exploring the pattern space and characterizing elements in a top-down method would be helpful. In particular, we seek a group of specialized queries that create embedded partitions of a single query.

We would like to emphasise that our primary aim is to offer formalisation and examples of how the model can be applied, with the added goal of producing a real implementation that is practical for use[<https://github.com/palmagro/ggq>].




 §.§ Preliminaries


This passage presents preliminary concepts for defining graph queries. For a more complete review, refer to <cit.>.  

We will begin with a graph definition that encompasses several common types found in literature, such as directed/undirected graphs, multi-relational graphs, and hypergraphs. This definition serves as a foundational basis for general graph dataset structures and queries.


A Graph is a tuple G = (V, E, μ) where:


  * V and E are sets, called, respectively, set of nodes and set of edges of G.

  * μ associates each node/edge in the graph with a set of properties μ: (V ∪ E) × R → J, where R represents the set of keys for  properties, and J the set of values. 
 

Furthermore, it is necessary to have a distinct key for the edges of the graph, called incidences and denoted by γ, which associates each edge in E with a set of vertices in V.

The domain of μ is the Cartesian product of the sets V ∪ E and R. Generally, we denote α(x) instead of μ(x,α) for each x∈ V∪ E and α∈ R, treating properties as maps from nodes/edges to values. Note that unlike standard definitions, the items in E are symbols that indicate the edges, rather than pairs of elements from V. Additionally, gamma is the function that matches each edge to the group of nodes, ordered or otherwise, that it connects. 

We will use γ(v) to denote the edges in which node v∈ V participates. The neighbourhood of v is the set of nodes, including itself, connected to it, that is, 𝒩(v) = ⋃_e ∈γ (v)γ (e). 

For instance, we could depict a binary social graph G, which encompasses a set of nodes V, a set of edges E, and a function μ that associates each node/edge in the graph with a set of properties R. Our social graph would comprise the attribute τ∈ R that may assume the values person and photo for the nodes and follows and like for edges. The attribute gamma ∈ R would be responsible for associating a pair of nodes in V with each edge. Furthermore, nodes and edges may possess additional attributes, such as age for nodes with τ = person or date for edges with τ = like.

We need to provide an understanding of the position of a node in an edge. We offer a basic definition of position, but a more comprehensive one can be provided to distinguish between directed and undirected edges:


If e∈ E and γ(e)=(v_1,…,v_n)∈ V^n, then we define the position of each v_i∈γ(e) in e as ord_e(v_i)=i. We denote u≤_e v to indicate ord_e(u)≤ ord_e(v).


From this ordering of the nodes on an edge, we can establish paths within a graph.


Given a graph G=(V,E,μ), we define the set of paths in G as 𝒫_G, which is the smallest set that satisfies the conditions:

    
  * If e∈ E and u, v∈γ (e) with u ≤_e v, then ρ=u e→ v∈𝒫_G. We will say that ρ connects the nodes u and v of G, and we will denote it by u ρ⇝ v.
    
  * If ρ_1, ρ_2∈𝒫_G, with u ρ_1⇝ v and v ρ_2⇝ w then ρ_1·ρ_2 ∈𝒫_G, with u ρ_1·ρ_2⇝ w.



Some useful notations are as follows:
	
	
  * If u ρ⇝ v, then we write ρ^o=u and ρ^i=v.
	
  * We denote the paths through u, starting in u, and ending in u, respectively, by:
	
    𝒫_u(G)={ρ∈𝒫(G): u∈ρ},

	
    𝒫_u^o(G)={ρ∈𝒫(G): ρ^o=u},

	
    𝒫_u^i(G)={ρ∈𝒫(G): ρ^i=u}.


For example, for a graph G with V={v_1,v_2,v_3} and E={e_1,e_2}, γ(e_1) = {v_1,v_2} and γ(e_2) = {v_2,v_3}, the set of paths comprises 𝒫_G = { v_1 e_1⇝  v_2,v_2 e2⇝  v_3,v_1 e1· e2⇝  v_3} with 𝒫^o_v_1(G)={ v_1 e1⇝  v_2,v_1 e1· e_2⇝  v_3} and  𝒫^i_v_1(G)=∅ .
The concept of a subgraph is acquired by employing the customary procedure of enforcing that the features are sustained within the intersecting elements.


    A subgraph of G = (V, E,μ) is defined as a graph S = (V_S, E_S,μ_S) where V_S is a subset of V, E_S is a subset of E, and μ_S is a subset of μ_|V_S ∪ E_S. We denote S ⊆ G. 


An instance of a subgraph from the graph stated earlier could be constituted by V_S={v_1,v_2}, E_S={e_1}, and γ|V_S ∪ E_S.



 §.§ Graph queries


As mentioned previously, our graph query framework aims to enable the generation of complementary queries based on a given query. This entails ensuring that if a subgraph does not comply with a query, it must always comply with one of its complementaries. However, since projection hinders the evaluation of non-existent elements, which is necessary for achieving complementarity, we propose the use of logical predicates instead of projections. 

In the following, we examine a graph that is prefixed, denoted by G=(V,E,μ). We will provide a brief formalization of our understanding of a predicate for G. More details on this topic can be found in <cit.>.

Consider a collection of function, predicate, and constant symbols, called Θ, which includes all the properties in μ, together with constants associated with elements of G, and possibly some additional symbols (for example, metrics defined in G, such as degree). We can use Θ as a set of non-logical symbols in the first-order language with equality, L. In this scenario, a predicate in G is an element of the set of first-order formulas of L (Form(L)). The binary predicates on G are indicated as Form^2(L).


    A Query for G is a graph, specifically Q = (V_Q, E_Q, μ_Q), possessing α and θ properties in μ_Q, and satisfying the following conditions:
    
        
  * α:V_Q∪ E_Q→{+,-}.
        
  * θ:V_Q∪ E_Q→ Form^2(L).
    


Formally, Q depends on L and G, but since we will consider L and G as prefixed, we will write Q ∈𝒬 (instead of Q ∈𝒬(L, G)) to denote that Q is a query on G using L.  Note that once a query is defined, it can be applied to multiple graphs using the same language.

Intuitively, when examining a query, we utilize the second input of binary predicates to place limitations on the membership of subgraphs within G. Conversely, the first input should receive elements of the corresponding type with which it is associated. 

For example, if a,b∈ V_Q and e∈ E_Q, and (we will denote θ_x:=θ(x)):

    θ_a(v,S)   :=v∈ S,
    θ_b(v,S)   :=∃ z∈ S (z ⇝ v),
    θ_e(ρ,S)   :=∃ y,z (y ρ⇝ z ∧ y ∉ S∧ z∈ S).


The node-based θ_a(v,S) is defined to check whether the subgraph evaluation of S contains v∈ V. The node-based θ_b(v,S) is verified only when a path in G connects a node of S with v∈ G. Lastly, the path-based θ_e(ρ,S) is defined to verify if the evaluated path ρ∈𝒫_G connects S with its outward in G.

Given a query under the stated conditions, x^+ (resp. x^-) is used to denote α (x) = + (resp. α (x) = -), and V_Q^+/V_Q^- (resp. E_Q^+/E_Q^-) represent the set of positive/negative nodes (resp. edges). If θ_x is not explicitly defined for an element, it is assumed to be a tautology.

According to the following definition, positive elements impose constraints on the presence of queries, while negative elements impose constraints on their absence. To be more specific, each positive/negative node in a query requires the existence/non-existence of a node in G which satisfies its conditions (imposed by θ_x and its edges):



    Given S⊆ G, and Q∈𝒬, we say that S matches Q (S Q), if the following formula holds:

    
    Q(S)=⋀_n∈ V_Q Q_n^α(n)(S)

		where, for each node, n∈ V_Q:	        
		
    Q_n^+ = Q_n, Q_n^- =  Q_n,
                	        
		
    Q_n(S)=∃ v∈ V (⋀_e∈γ(n) Q_e^*^α(e)(v,S))
	        
	    and, for each edge, e∈ E_Q, *∈{o,i}:
	    
    Q_e^*^+ = Q_e^*, Q_e^*^- =  Q_e^*,


        
    Q_e^o(v,S)=∃ρ∈𝒫_v^o(G) (θ_e(ρ,S)∧θ_e^o(ρ^o,S) ∧θ_e^i(ρ^i,S)),

        
    Q_e^i(v,S)=∃ρ∈𝒫_v^i(G) (θ_e(ρ,S)∧θ_e^o(ρ^o,S) ∧θ_e^i(ρ^i,S)).






A generic query example is shown in Figure <ref>.


    

        
    < g r a p h i c s >

    

    
        Graph Query Example
    
    


Unlike other previous graph query systems, this system can efficiently satisfy the following requirements: (1) the ability to contain cycles; (2) the capability to evaluate subgraphs; (3) projecting edges in the query onto paths in the graph; (4) evaluating structural and/or semantic characteristics; and (5) the added benefit of specialization through atomic operations (as will be discussed in the next section).



 §.§ Refinement sets
    


To properly characterize the elements within a graph, it is crucial to utilize computationally effective methods when constructing queries based on basic operations. This section will introduce a query construction method optimized for use in relational learning tasks. To begin, let us first define the concept of relative refinements between queries.


    Given Q_1, Q_2∈𝒬, we say:
    
    	
  * Q_1 refines Q_2 in G (Q_1≼_G Q_2) if:
    	∀ S⊆ G (S Q_1 ⇒ S Q_2).
    	
  * They are equivalent in G (Q_1≡_G Q_2) if:
    	Q_1≼_G Q_2 and Q_2≼_G Q_1.
     


Two queries are deemed equivalent when they are confirmed to be exactly the same by identical subgraphs. From this definition, it is straightforward the following result is straightforward (the proof of which may be omitted):


    ≼_G is a partial order in 𝒬. That is, for every Q_1, Q_2, Q_3 ∈𝒬:
    
        
  * Q_1≼_G Q_1.
        
  * Q_1≼_G Q_2 ∧ Q_2≼_G Q_1 ⇒ Q_1≡_G Q_2.
        
  * Q_1≼_G Q_2 ∧ Q_2≼_G Q_3 ⇒ Q_1≼_G Q_3.
    


Next, we examine the relationship between the topological structure of a query and its functionality as a predicate on subgraphs. Generally, extracting logical properties of the predicate from the structural properties of the graph that represents it is difficult. However, we can obtain useful conditions to manipulate the structures and modify the query's semantics in a controlled manner.


    Given Q_1, Q_2∈𝒬, we say that Q_1 is a Q^--conservative extension of Q_2 (Q_2⊆^- Q_1) if:
    
        
  * Q_2⊆ Q_1.
        
  * ∀ n∈ V_Q_2^- ∀ e∈γ_Q_1(n) ∃ e'∈γ_Q_2(n) (Q_e≡ Q_e').
        
    


Figure <ref> illustrates an example of a Q^--conservative extension. The novel element in the right query mandates fresh constraints on the positive node, but it does not introduce any additional constraints to the negative one.


    

        
    < g r a p h i c s >

    

    
        Q^--conservative extension
    
    


Since negative nodes introduce non-existence constraints to subgraph verification, Q^--conservative extensions guarantee that no new constraints are added to them. Therefore:


    If Q_2⊆^- Q_1 then Q_1≼ Q_2.


	Since predicates associated to edges are solely based on the information within the edge itself (which takes into account the value of θ in its incident nodes, irrespective of their α value), we can assert that:
	
    ∀ e∈ E_Q_2 (Q_1_e^α(e)=Q_2_e^α(e))

	
	Considering this fact, we examine the behaviour of predicates associated with the nodes for both queries:
	
		
  * If  n∈ V_Q_2^-, since Q_2⊆^- Q_1, then Q_1_n^-=Q_2_n^-.
		
  * If n∈ V_Q_2^+, then Q_1_n^+→Q_2_n^+, because (γ_1, γ_2 are the incidence functions of Q_1 and Q_2, respectively):
		
    Q_1_n^+      = ∃ v∈ V ( ⋀_e∈γ_1(n)Q_1_e^α(e))
       = ∃ v∈ V( ⋀_e∈γ_1(n)∩ E_Q_2Q_1_e^α(e) ∧ ⋀_e∈γ_1(n)∖ E_Q_2Q_1_e^α(e))
       = ∃ v∈ V( ⋀_e∈γ_2(n)∩ E_Q_2Q_2_e^α(e) ∧ ⋀_e∈γ_1(n)∖ E_Q_2Q_1_e^α(e))
       →Q_2_n^+

	
	Hence:
	
    Q_1    = ⋀_n∈ V_Q_1Q_1_n^α(n) = ⋀_n∈ V_Q_2Q_1_n^α(n) ∧ ⋀_n∈ V_Q_1∖ V_Q_2Q_1_n^α(n)
       = ⋀_n∈ V_Q_2^+Q_1_n^α(n) ∧ ⋀_n∈ V_Q_2^-Q_1_n^α(n) ∧ ⋀_n∈ V_Q_1∖ V_Q_2Q_1_n^α(n)

	
    →⋀_n∈ V_Q_2^+Q_2_n^α(n) ∧ ⋀_n∈ V_Q_2^-Q_2_n^α(n) ∧ ⋀_n∈ V_Q_1∖ V_Q_2Q_1_n^α(n)
       = ⋀_n∈ V_Q_2Q_2_n^α(n) ∧ ⋀_n∈ V_Q_1∖ V_Q_2Q_1_n^α(n)
       →Q_2


Previous result suggests that a query can be refined by adding nodes (of any sign) and edges to the existing positive nodes, but because of the (negated) interpretation of predicates associated with negative nodes, care must be taken to maintain their neighborhood to be sure that adding more edges does not weaken the imposed conditions (which consequently will not provide refined predicates).

To achieve controlled methods of query generation, we will outline processes for refining queries through unit steps. We shall accomplish this by defining the cloning operation, whereby existing nodes are duplicated, and all incident edges (including those between the nodes) on the original graph are also cloned: 


    Given G=(V,E,μ), and W⊆ V, we define the clone of G by duplication of W, Cl_G^W, as:
    
    
    Cl_G^W=(V∪ W',E∪ E',μ∪{(n',μ(n))}_n∈ W∪{(e',μ(e))}_e'∈ E')

    where W'={n' : n∈ W} are new cloned nodes from W, and E ' is a set of new edges obtained from incident edges on nodes of W where nodes of W are replaced by copies of W' (edges connecting original nodes with cloned nodes and edges connecting cloned nodes, are cloned).


Figure <ref> shows an example of a cloned graph by duplicating two nodes (in the original graph, left side, the set of nodes to be duplicated is highlighted).

    

        
    < g r a p h i c s >

    

    
        Clone of a graph by duplication
    
    


The next result indicates that duplicating positive nodes does not change the meaning of the queries.


    If W⊆ V^+_Q, then Cl_Q^W≡ Q.


	Let us denote Q_1 = Cl_Q^W. Then:
	
    Q_1    = ⋀_n∈ V_Q_1Q_1_n^α(n)
    	 =⋀_n∈ V_QQ_1_n^α(n) ∧ ⋀_n∈ WQ_1_n'^α(n')
       = ⋀_n∈ V_Q∖γ_Q(W)Q_1_n^α(n) ∧ ⋀_n∈γ_Q(W)Q_1_n^α(n) ∧ ⋀_n∈ WQ_1_n'^α(n')
       = ⋀_n∈ V_Q∖γ_Q(W) Q_n^α(n) ∧⋀_n∈γ_Q(W) Q_n^α(n) ∧ ⋀_n∈ W Q_n^α(n)
       = Q



When refining a query to find complementary sets of selected subgraphs, we define the concept of a refinement set as central:


    Given Q∈𝒬, R⊆𝒬 is a refinement set of Q in G if:
    
        
  * ∀ Q'∈ R (Q'≼_G Q).
        
  * ∀ S⊆ G (S Q⇒∃ ! Q'∈ R (S Q')).
    


Let us now introduce refinement sets to enhance simpler queries for expressiveness. Q∈𝒬 is prefixed, and ⊤ represents a tautology:

(Add new node)
    If m∉ V_Q, the set Q+{m}, formed by:
        
    Q_1    = (V_Q∪{m}, E_Q, α_Q∪(m,+), θ_Q∪(m,⊤)) , 
     
             Q_2    = (V_Q∪{m}, E_Q, α_Q∪(m,-), θ_Q∪(m,⊤))

    is a refinement set of Q in G (Fig. <ref>).


	We must verify the two necessary conditions for refinement sets:
	
		
  * Since Q⊆^- Q_1 and Q⊆^- Q_2, thus Q_1≼ Q and Q_2≼ Q.
		
  * Given S⊆ G such that S Q. Then:
		
    Q_1   = Q ∧ Q_m ,
    
    		Q_2   = Q ∧  Q_m

		where Q_m=∃ v∈ V (⊤).
		
		If G≠∅, then S Q_1 and S⊭ Q_2.
		
		If G= ∅, then S⊭ Q_1 and S Q_2.
	


Since G ≠∅ (usually), Q_1 ≡ Q. However, although we obtain an equivalent query, this operation is beneficial for adding new nodes and restrictions in the future.


    

        
    < g r a p h i c s >

    

    
        Add node refinement
    
    


The second refinement allows for the establishment of edges between query nodes that already exist. To obtain a valid refinement set, the inclusion of edges is limited to positive nodes. Subsequently, the nodes marked with a positive/negative sign represent cloned nodes whose α property has been designated as positive/negative.

(Add new edge between + nodes)
    If n,m∈ V_Q^+, the set Q+{ne^*⟶ m} (*∈{+,-}), formed by:
    
    Q_1    = (V_Q', E_Q'∪{n^+e^*⟶ m^+}, θ_Q'∪(e,⊤)), 
    
        Q_2    = (V_Q', E_Q'∪{n^+e^*⟶ m^-}, θ_Q'∪(e,⊤)), 
    
        Q_3    = (V_Q', E_Q'∪{n^-e^*⟶ m^+}, θ_Q'∪(e,⊤)), 
    
        Q_4    = (V_Q', E_Q'∪{n^-e^*⟶ m^-}, θ_Q'∪(e,⊤))

    (where Q'=Cl_Q^{n,m}) is a refinement set of Q in G (Fig. <ref>).


	  
		
  * Since Q' is a clone of Q, then Q≡ Q'. In addition,  Q'⊆^- Q_1,Q_2,Q_3,Q_4, thus Q_1,Q_2,Q_3,Q_4≼ Q'≡ Q.
		
  * Let us consider the predicates:
		
    P_n    = ∃ v∈ V ( ⋀_a∈γ(n) Q_a^α(a) ∧ Q_e^o^α(e)), 
    
    		P_m    = ∃ v∈ V ( ⋀_a∈γ(m) Q_a^α(a) ∧ Q_e^i^α(e)).

		If S Q_n and S Q_m, then we have four mutually complementary options:
		
			
  * S P_n ∧ S P_m ⇒ S Q_1
			
  * S P_n ∧ S⊭ P_m ⇒ S Q_2
			
  * S⊭ P_n ∧ S P_m ⇒ S Q_3
			
  * S⊭ P_n ∧ S⊭ P_m ⇒ S Q_4
		
	



    

        
    < g r a p h i c s >

    

    
        Add edge refinement (simplified)
    
    


Next, an additional predicate is added to an existing edge through the following operation, limited to positive edges connecting positive nodes.

(Add predicate to + edge between + nodes)
    If n,m∈ V_Q^+, with ne^+⟶ m, and φ∈ Form^2(L), the set Q+{ne ∧φ⟶ m}, formed by:
    
    Q_1    = (V_Q', E_Q'∪{n^+e'⟶ m^+}, θ_Q'∪(e',θ_e∧φ)), 
    
        Q_2    = (V_Q', E_Q'∪{n^+e'⟶ m^-}, θ_Q'∪(e',θ_e∧φ)), 
    
        Q_3    = (V_Q', E_Q'∪{n^-e'⟶ m^+}, θ_Q'∪(e',θ_e∧φ)), 
    
        Q_4    = (V_Q', E_Q'∪{n^-e'⟶ m^-}, θ_Q'∪(e',θ_e∧φ))

    (where Q'=Cl_Q^{n,m}) is a refinement set of Q in G (Fig. <ref>).


	The proof is similar to the previous ones.



    

        
    < g r a p h i c s >

    

    
	Add predicate to edge refinement (simplified)
    
    


Finally, the last step involves adding predicates to existing nodes. This operation is only permitted when the affected nodes are positive, including the node where the predicate is added and those connected to it.

(Add predicate to + node with + neighborhood)
    If φ∈ Form^2(L), and n∈ V_Q^+ with 𝒩_Q(n)⊆ V_Q^+, then the set Q+{n∧φ} formed by:
    
    {Q_σ=(V_Q',E_Q',α_Q'∪σ,θ_Q'∪(n',θ_n∧φ)) : σ∈{+,-}^𝒩_Q(n)}
 	
(where Q'=Cl_Q^𝒩_Q(n), and {+,-}^𝒩_Q(n) is the set of all possible assignments of signs to elements in 𝒩_Q(n))
is a refinement set of Q in G (Fig. <ref>).


	The proof resembles earlier ones. It is important to consider that modifying node n not only alters the associated predicate, but also those of its neighboring nodes. Additionally, the set of functions {+, -}^𝒩_Q(n) encompasses all feasible sign assignments for the nodes within the neighborhood.



    

        
    < g r a p h i c s >

    

    
        Add predicate to node refinement (simplified)
    
    


Also note that simplified versions of the refinement sets are shown in Figures <ref>-<ref>. Section <ref> provides an explanation on how to obtain these simplifications.

Obtaining a complementary query from the structure is a challenging task. Nonetheless, graph analyses often require sequences of queries to verify properties related to refinement and complementarity. To bridge this gap, this section introduces refinement operations. These operations facilitate the construction of an embedded partition tree, where nodes are labelled as illustrated in Figure <ref>:


    
  * The root node is labeled with Q_0 (some initial query).
    
  * If a node on the tree is labelled with Q, and R={Q_1,…,Q_n} is a set that refines Q, then the child nodes will be labelled with the elements of R.



    

        
    < g r a p h i c s >

    

    
        Refinements tree
    
    


Refinement sets presented herein offer one approach, rather than the sole approach. For example, we could consider refinements that, instead of adding constraints to positive elements, lighten the conditions over negative elements, for example, by using disjunction of predicates instead of conjunction of them.



 §.§ Simplified refinement sets


Let us simplify a query into an equivalent one by applying certain operations.


    We define Q'⊆ Q as redundant in Q if Q≡ Q-Q'. Here, Q-Q' represents the subgraph of Q given by:
	
    (V_Q∖ V_Q', E_Q∖ (E_Q'∪{γ(n): n∈ V_Q'}),μ_Q)




One initial finding that enables the acquisition of simplified versions of a query by eliminating superfluous nodes is (from the following two results we only give an idea of the proof, which can be very laborious but straightforward from the above constructions):


	Given a query Q, and n,m∈ V_Q verifying:
	
		
  * α(n)=α(m)
		
  * θ_n≡θ_m
		
  * For each e∈γ(n), exists e'∈γ(m), with α(e)=α(e'), θ_e≡θ_e' and γ(e)∖{n}=γ(e')∖{m}
	
	Then, n is redundant in Q.





A query Q comprises nodes and their relationships. Each query node imposes constraints on the subgraph that is evaluated, including the presence or absence of nodes and the paths in which they participate. These restrictions should be considered during the evaluation. If there are two nodes n,m ∈ V_Q with α(n) = α(m) and θ_n≡θ_m, and for each e∈γ(n), there exists e'∈γ(m), with α(e)=α(e'), θ_e≡θ_e' and γ(e)∖{n}=γ(e')∖{m}, both nodes apply identical restrictions to the subgraph being evaluated. Therefore, deleting one of them will not change the assessment on the subgraph.



Essentially, m is a duplicate of n, but potentially with additional connected edges. A comparable outcome for the edges can be achieved:


    Given a query Q, and two edges, e, e'∈ E_Q, such that α(e)=α(e'), ne⟶ m and ne'⟶ m with n,m ∈ V_Q^+. If θ_e→θ_e' then e' is redundant in Q.





Following the same reasoning as the previous theorem, if there are two edges, e and e', in E_Q, which connect the same two nodes in a query and α(e)=α(e') and θ_e→θ_e', the constraint imposed by e implies the constraint imposed by e'. Therefore, eliminating e' would maintain the set of matching subgraphs.



From these two findings, we can streamline the refinement sets that were established in section <ref> by removing redundant elements in succession after cloning. 



 §.§ Graph query examples


For illustrative purposes, this section presents a series of queries on a toy graph dataset. Figure <ref> illustrates a segment of the Starwars graph[http://console.neo4j.org/?id=StarWars].


    

        
    < g r a p h i c s >

    

    
        Section of Starwars Graph
    
    


To streamline query and graph representation, we will convert τ, a property denoting node and edge types, into labels for edges or icons for nodes. Additionally, the node properties denoted by name will be written on them, and the undirected edges will be represented by bidirectional arrows. The property α will be represented directly on query elements using + / - symbols, and we will write the binary predicate θ directly on the elements (except for tautologies). When expressions such as τ (ρ) = X are in the predicate of an edge, X is written directly and interpreted as a regular expression to be verified by the sequence of τ properties of the links in the associated graph path. 


    

        
    < g r a p h i c s >

    

    
        Query 1
    
    


Query 1 (Figure <ref>) can be interpreted as follows: Two characters are connected by a TEACHES relationship, where the master is over 500 years old and both are devoted to the Jedi. This query utilizes structural constraints through the presence of edges and predicates with properties such as τ, name, and age. For example, in Figure <ref>, the subgraph comprising , , and their  relationship satisfies this query. 


    

        
    < g r a p h i c s >

    

    
      Query 2
    
    


Query 2 (Figure <ref>) outlines a cyclic query that utilises  relationships. It will be verified on any subgraph containing three characters who are friends with each other (for example, the subgraph formed by , ,  and the  relationships between them in Figure <ref>).


    

        
    < g r a p h i c s >

    

    
        Query 3
    
    


Query 3 (Figure <ref>) can be interpreted as follows: A character with more than 3 outgoing relationships, not belonging to the Sith clan, connected through a path consisting of any number of FRIENDS and TEACHES relationships with an individual from Alderaan. In this scenario, a regular expression has been employed to denote a path consisting of an unspecified amount of  and  relationships. Additionally, an auxiliary function, gr_s(v) ∈ L, has been utilised to reference the outgoing degree of node v. This query will be validated by any subgraph that contains  or .



 §.§ Computational complexity


Query systems based on graph isomorphisms (most of the existing ones) face NP-complete complexity  <cit.>.

The preceding section presented our graph query framework that is reliant on logical predicates. In this section, we will demonstrate that the assessment of queries is polynomial, even in the case of cyclic queries. This is achievable by imposing two constraints. First, the length of paths that are illustrated by links in the query is restricted by the constant k, and second, the complexity of the predicates used in nodes and edges is polynomial.

To verify S Q, it is necessary to examine each predicate Q_n(S) linked to all nodes n ∈ V_Q. Furthermore, each predicate Q_n(S) linked to a node in Q requires assessing one Q_e(v,S) predicate for every link e∈γ_Q(n). Thus, initially, we shall focus on evaluating the computational complexity linked with the link predicates Q_e(v,S). Subsequently, we shall proceed to examine the complexity associated with the node predicates Q_n(S). Ultimately, we shall exhibit that the query complexity is polynomial.

As previously defined, the computational complexity of evaluating predicates attributed to both nodes and edges within a query Q is polynomial, denoted by 𝒪(p). The predicates Q_e(v,S) related to edges in a query verify the existence of a path ρ in the graph G starting/ending in v that satisfies its own predicate θ_e (ρ, S) and with the source and destination nodes that satisfy the predicates θ_e^o (ρ^o , S) and θ_e^i (ρ^i , S) respectively. Thus, the complexity involved in evaluating a particular path is 𝒪(3p) = 𝒪(p). 

The computational complexity to verify the existence of a path beginning or ending at a node v in V, satisfying the aforementioned criteria, is 𝒪(p × |V|^k). Here, |V|^k denotes the number of paths that start or end at v under the condition that they are no longer than k in length. As the number of links commencing or ending at a node n ∈ V_Q is bound by |E_Q|, the computational complexity involved in the node predicate Q_n(S) is 𝒪(p× |V|^k × |E_Q|). 

Finally, if the query consists of |V_Q| nodes, the complexity of checking the query Q(S) is 𝒪(p× |V|^k × |E_Q| × |V_Q|). It is evident that the constant k (path length bound) significantly impacts the execution of such queries, as it determines the exponent of the complexity.

Efficient operation of a graph query framework is crucial when dealing with large-scale data sets that are commonly found in real-world applications. Notably, when such a system is employed as the kernel of relational machine learning algorithms, as we will demonstrate in the following section, the ability to perform query operations in polynomial time, even for cyclic queries, is fundamental.
---------------------------fin chunk----------------
