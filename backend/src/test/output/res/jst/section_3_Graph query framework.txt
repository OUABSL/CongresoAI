



Â§ GRAPH QUERY FRAMEWORK



In graph pattern matching, precise definitions are fundamental for research. They create a shared terminology, whilst theorems illustrated by mathematical proofs reveal essential characteristics and direct the development of algorithms. This paper presents a mathematical tool for conducting graph pattern matching. We will do this by utilising these mathematical tools.

We are exploring graph queries that enable atomic specialisations. We aim to produce pattern specialisations that select only a particular subset of elements by utilising a set of elements that satisfy a specific relational pattern. Selection Graphs serves as an instance of this query tool and has been developed for use in relational learning procedures. However, it has a fundamental limitation, as its patterns are unable to include cycles. Furthermore, when dealing with high relational data, incorporating a graphical representation of SQL queries can lead to efficiency issues. Our proposal draws inspiration from this method while bypassing its possible constraints. 

When searching for query specialization, we aim to also create complementary queries to cover new conditions. Exploring the pattern space and characterizing elements in a top-down method would be helpful. In particular, we seek a group of specialized queries that create embedded partitions of a single query.

We would like to emphasise that our primary aim is to offer formalisation and examples of how the model can be applied, with the added goal of producing a real implementation that is practical for use[<https://github.com/palmagro/ggq>].




 Â§.Â§ Preliminaries


This passage presents preliminary concepts for defining graph queries. For a more complete review, refer to <cit.>.  

We will begin with a graph definition that encompasses several common types found in literature, such as directed/undirected graphs, multi-relational graphs, and hypergraphs. This definition serves as a foundational basis for general graph dataset structures and queries.


A Graph is a tuple G = (V, E, Î¼) where:


  * V and E are sets, called, respectively, set of nodes and set of edges of G.

  * Î¼ associates each node/edge in the graph with a set of properties Î¼: (V âˆª E) Ã— R â†’ J, where R represents the set of keys for  properties, and J the set of values. 
 

Furthermore, it is necessary to have a distinct key for the edges of the graph, called incidences and denoted by Î³, which associates each edge in E with a set of vertices in V.

The domain of Î¼ is the Cartesian product of the sets V âˆª E and R. Generally, we denote Î±(x) instead of Î¼(x,Î±) for each xâˆˆ Vâˆª E and Î±âˆˆ R, treating properties as maps from nodes/edges to values. Note that unlike standard definitions, the items in E are symbols that indicate the edges, rather than pairs of elements from V. Additionally, gamma is the function that matches each edge to the group of nodes, ordered or otherwise, that it connects. 

We will use Î³(v) to denote the edges in which node vâˆˆ V participates. The neighbourhood of v is the set of nodes, including itself, connected to it, that is, ğ’©(v) = â‹ƒ_e âˆˆÎ³ (v)Î³ (e). 

For instance, we could depict a binary social graph G, which encompasses a set of nodes V, a set of edges E, and a function Î¼ that associates each node/edge in the graph with a set of properties R. Our social graph would comprise the attribute Ï„âˆˆ R that may assume the values person and photo for the nodes and follows and like for edges. The attribute gamma âˆˆ R would be responsible for associating a pair of nodes in V with each edge. Furthermore, nodes and edges may possess additional attributes, such as age for nodes with Ï„ = person or date for edges with Ï„ = like.

We need to provide an understanding of the position of a node in an edge. We offer a basic definition of position, but a more comprehensive one can be provided to distinguish between directed and undirected edges:


If eâˆˆ E and Î³(e)=(v_1,â€¦,v_n)âˆˆ V^n, then we define the position of each v_iâˆˆÎ³(e) in e as ord_e(v_i)=i. We denote uâ‰¤_e v to indicate ord_e(u)â‰¤ ord_e(v).


From this ordering of the nodes on an edge, we can establish paths within a graph.


Given a graph G=(V,E,Î¼), we define the set of paths in G as ğ’«_G, which is the smallest set that satisfies the conditions:

    
  * If eâˆˆ E and u, vâˆˆÎ³ (e) with u â‰¤_e v, then Ï=u eâ†’ vâˆˆğ’«_G. We will say that Ï connects the nodes u and v of G, and we will denote it by u Ïâ‡ v.
    
  * If Ï_1, Ï_2âˆˆğ’«_G, with u Ï_1â‡ v and v Ï_2â‡ w then Ï_1Â·Ï_2 âˆˆğ’«_G, with u Ï_1Â·Ï_2â‡ w.



Some useful notations are as follows:
	
	
  * If u Ïâ‡ v, then we write Ï^o=u and Ï^i=v.
	
  * We denote the paths through u, starting in u, and ending in u, respectively, by:
	
    ğ’«_u(G)={Ïâˆˆğ’«(G): uâˆˆÏ},

	
    ğ’«_u^o(G)={Ïâˆˆğ’«(G): Ï^o=u},

	
    ğ’«_u^i(G)={Ïâˆˆğ’«(G): Ï^i=u}.


For example, for a graph G with V={v_1,v_2,v_3} and E={e_1,e_2}, Î³(e_1) = {v_1,v_2} and Î³(e_2) = {v_2,v_3}, the set of paths comprises ğ’«_G = { v_1 e_1â‡  v_2,v_2 e2â‡  v_3,v_1 e1Â· e2â‡  v_3} with ğ’«^o_v_1(G)={ v_1 e1â‡  v_2,v_1 e1Â· e_2â‡  v_3} and  ğ’«^i_v_1(G)=âˆ… .
The concept of a subgraph is acquired by employing the customary procedure of enforcing that the features are sustained within the intersecting elements.


    A subgraph of G = (V, E,Î¼) is defined as a graph S = (V_S, E_S,Î¼_S) where V_S is a subset of V, E_S is a subset of E, and Î¼_S is a subset of Î¼_|V_S âˆª E_S. We denote S âŠ† G. 


An instance of a subgraph from the graph stated earlier could be constituted by V_S={v_1,v_2}, E_S={e_1}, and Î³|V_S âˆª E_S.



 Â§.Â§ Graph queries


As mentioned previously, our graph query framework aims to enable the generation of complementary queries based on a given query. This entails ensuring that if a subgraph does not comply with a query, it must always comply with one of its complementaries. However, since projection hinders the evaluation of non-existent elements, which is necessary for achieving complementarity, we propose the use of logical predicates instead of projections. 

In the following, we examine a graph that is prefixed, denoted by G=(V,E,Î¼). We will provide a brief formalization of our understanding of a predicate for G. More details on this topic can be found in <cit.>.

Consider a collection of function, predicate, and constant symbols, called Î˜, which includes all the properties in Î¼, together with constants associated with elements of G, and possibly some additional symbols (for example, metrics defined in G, such as degree). We can use Î˜ as a set of non-logical symbols in the first-order language with equality, L. In this scenario, a predicate in G is an element of the set of first-order formulas of L (Form(L)). The binary predicates on G are indicated as Form^2(L).


    A Query for G is a graph, specifically Q = (V_Q, E_Q, Î¼_Q), possessing Î± and Î¸ properties in Î¼_Q, and satisfying the following conditions:
    
        
  * Î±:V_Qâˆª E_Qâ†’{+,-}.
        
  * Î¸:V_Qâˆª E_Qâ†’ Form^2(L).
    


Formally, Q depends on L and G, but since we will consider L and G as prefixed, we will write Q âˆˆğ’¬ (instead of Q âˆˆğ’¬(L, G)) to denote that Q is a query on G using L.  Note that once a query is defined, it can be applied to multiple graphs using the same language.

Intuitively, when examining a query, we utilize the second input of binary predicates to place limitations on the membership of subgraphs within G. Conversely, the first input should receive elements of the corresponding type with which it is associated. 

For example, if a,bâˆˆ V_Q and eâˆˆ E_Q, and (we will denote Î¸_x:=Î¸(x)):

    Î¸_a(v,S)   :=vâˆˆ S,
    Î¸_b(v,S)   :=âˆƒ zâˆˆ S (z â‡ v),
    Î¸_e(Ï,S)   :=âˆƒ y,z (y Ïâ‡ z âˆ§ y âˆ‰ Sâˆ§ zâˆˆ S).


The node-based Î¸_a(v,S) is defined to check whether the subgraph evaluation of S contains vâˆˆ V. The node-based Î¸_b(v,S) is verified only when a path in G connects a node of S with vâˆˆ G. Lastly, the path-based Î¸_e(Ï,S) is defined to verify if the evaluated path Ïâˆˆğ’«_G connects S with its outward in G.

Given a query under the stated conditions, x^+ (resp. x^-) is used to denote Î± (x) = + (resp. Î± (x) = -), and V_Q^+/V_Q^- (resp. E_Q^+/E_Q^-) represent the set of positive/negative nodes (resp. edges). If Î¸_x is not explicitly defined for an element, it is assumed to be a tautology.

According to the following definition, positive elements impose constraints on the presence of queries, while negative elements impose constraints on their absence. To be more specific, each positive/negative node in a query requires the existence/non-existence of a node in G which satisfies its conditions (imposed by Î¸_x and its edges):



    Given SâŠ† G, and Qâˆˆğ’¬, we say that S matches Q (S Q), if the following formula holds:

    
    Q(S)=â‹€_nâˆˆ V_Q Q_n^Î±(n)(S)

		where, for each node, nâˆˆ V_Q:	        
		
    Q_n^+ = Q_n, Q_n^- =  Q_n,
                	        
		
    Q_n(S)=âˆƒ vâˆˆ V (â‹€_eâˆˆÎ³(n) Q_e^*^Î±(e)(v,S))
	        
	    and, for each edge, eâˆˆ E_Q, *âˆˆ{o,i}:
	    
    Q_e^*^+ = Q_e^*, Q_e^*^- =  Q_e^*,


        
    Q_e^o(v,S)=âˆƒÏâˆˆğ’«_v^o(G) (Î¸_e(Ï,S)âˆ§Î¸_e^o(Ï^o,S) âˆ§Î¸_e^i(Ï^i,S)),

        
    Q_e^i(v,S)=âˆƒÏâˆˆğ’«_v^i(G) (Î¸_e(Ï,S)âˆ§Î¸_e^o(Ï^o,S) âˆ§Î¸_e^i(Ï^i,S)).






A generic query example is shown in Figure <ref>.


    

        
    < g r a p h i c s >

    

    
        Graph Query Example
    
    


Unlike other previous graph query systems, this system can efficiently satisfy the following requirements: (1) the ability to contain cycles; (2) the capability to evaluate subgraphs; (3) projecting edges in the query onto paths in the graph; (4) evaluating structural and/or semantic characteristics; and (5) the added benefit of specialization through atomic operations (as will be discussed in the next section).



 Â§.Â§ Refinement sets
    


To properly characterize the elements within a graph, it is crucial to utilize computationally effective methods when constructing queries based on basic operations. This section will introduce a query construction method optimized for use in relational learning tasks. To begin, let us first define the concept of relative refinements between queries.


    Given Q_1, Q_2âˆˆğ’¬, we say:
    
    	
  * Q_1 refines Q_2 in G (Q_1â‰¼_G Q_2) if:
    	âˆ€ SâŠ† G (S Q_1 â‡’ S Q_2).
    	
  * They are equivalent in G (Q_1â‰¡_G Q_2) if:
    	Q_1â‰¼_G Q_2 and Q_2â‰¼_G Q_1.
     


Two queries are deemed equivalent when they are confirmed to be exactly the same by identical subgraphs. From this definition, it is straightforward the following result is straightforward (the proof of which may be omitted):


    â‰¼_G is a partial order in ğ’¬. That is, for every Q_1, Q_2, Q_3 âˆˆğ’¬:
    
        
  * Q_1â‰¼_G Q_1.
        
  * Q_1â‰¼_G Q_2 âˆ§ Q_2â‰¼_G Q_1 â‡’ Q_1â‰¡_G Q_2.
        
  * Q_1â‰¼_G Q_2 âˆ§ Q_2â‰¼_G Q_3 â‡’ Q_1â‰¼_G Q_3.
    


Next, we examine the relationship between the topological structure of a query and its functionality as a predicate on subgraphs. Generally, extracting logical properties of the predicate from the structural properties of the graph that represents it is difficult. However, we can obtain useful conditions to manipulate the structures and modify the query's semantics in a controlled manner.


    Given Q_1, Q_2âˆˆğ’¬, we say that Q_1 is a Q^--conservative extension of Q_2 (Q_2âŠ†^- Q_1) if:
    
        
  * Q_2âŠ† Q_1.
        
  * âˆ€ nâˆˆ V_Q_2^- âˆ€ eâˆˆÎ³_Q_1(n) âˆƒ e'âˆˆÎ³_Q_2(n) (Q_eâ‰¡ Q_e').
        
    


Figure <ref> illustrates an example of a Q^--conservative extension. The novel element in the right query mandates fresh constraints on the positive node, but it does not introduce any additional constraints to the negative one.


    

        
    < g r a p h i c s >

    

    
        Q^--conservative extension
    
    


Since negative nodes introduce non-existence constraints to subgraph verification, Q^--conservative extensions guarantee that no new constraints are added to them. Therefore:


    If Q_2âŠ†^- Q_1 then Q_1â‰¼ Q_2.


	Since predicates associated to edges are solely based on the information within the edge itself (which takes into account the value of Î¸ in its incident nodes, irrespective of their Î± value), we can assert that:
	
    âˆ€ eâˆˆ E_Q_2 (Q_1_e^Î±(e)=Q_2_e^Î±(e))

	
	Considering this fact, we examine the behaviour of predicates associated with the nodes for both queries:
	
		
  * If  nâˆˆ V_Q_2^-, since Q_2âŠ†^- Q_1, then Q_1_n^-=Q_2_n^-.
		
  * If nâˆˆ V_Q_2^+, then Q_1_n^+â†’Q_2_n^+, because (Î³_1, Î³_2 are the incidence functions of Q_1 and Q_2, respectively):
		
    Q_1_n^+      = âˆƒ vâˆˆ V ( â‹€_eâˆˆÎ³_1(n)Q_1_e^Î±(e))
       = âˆƒ vâˆˆ V( â‹€_eâˆˆÎ³_1(n)âˆ© E_Q_2Q_1_e^Î±(e) âˆ§ â‹€_eâˆˆÎ³_1(n)âˆ– E_Q_2Q_1_e^Î±(e))
       = âˆƒ vâˆˆ V( â‹€_eâˆˆÎ³_2(n)âˆ© E_Q_2Q_2_e^Î±(e) âˆ§ â‹€_eâˆˆÎ³_1(n)âˆ– E_Q_2Q_1_e^Î±(e))
       â†’Q_2_n^+

	
	Hence:
	
    Q_1    = â‹€_nâˆˆ V_Q_1Q_1_n^Î±(n) = â‹€_nâˆˆ V_Q_2Q_1_n^Î±(n) âˆ§ â‹€_nâˆˆ V_Q_1âˆ– V_Q_2Q_1_n^Î±(n)
       = â‹€_nâˆˆ V_Q_2^+Q_1_n^Î±(n) âˆ§ â‹€_nâˆˆ V_Q_2^-Q_1_n^Î±(n) âˆ§ â‹€_nâˆˆ V_Q_1âˆ– V_Q_2Q_1_n^Î±(n)

	
    â†’â‹€_nâˆˆ V_Q_2^+Q_2_n^Î±(n) âˆ§ â‹€_nâˆˆ V_Q_2^-Q_2_n^Î±(n) âˆ§ â‹€_nâˆˆ V_Q_1âˆ– V_Q_2Q_1_n^Î±(n)
       = â‹€_nâˆˆ V_Q_2Q_2_n^Î±(n) âˆ§ â‹€_nâˆˆ V_Q_1âˆ– V_Q_2Q_1_n^Î±(n)
       â†’Q_2


Previous result suggests that a query can be refined by adding nodes (of any sign) and edges to the existing positive nodes, but because of the (negated) interpretation of predicates associated with negative nodes, care must be taken to maintain their neighborhood to be sure that adding more edges does not weaken the imposed conditions (which consequently will not provide refined predicates).

To achieve controlled methods of query generation, we will outline processes for refining queries through unit steps. We shall accomplish this by defining the cloning operation, whereby existing nodes are duplicated, and all incident edges (including those between the nodes) on the original graph are also cloned: 


    Given G=(V,E,Î¼), and WâŠ† V, we define the clone of G by duplication of W, Cl_G^W, as:
    
    
    Cl_G^W=(Vâˆª W',Eâˆª E',Î¼âˆª{(n',Î¼(n))}_nâˆˆ Wâˆª{(e',Î¼(e))}_e'âˆˆ E')

    where W'={n' : nâˆˆ W} are new cloned nodes from W, and E ' is a set of new edges obtained from incident edges on nodes of W where nodes of W are replaced by copies of W' (edges connecting original nodes with cloned nodes and edges connecting cloned nodes, are cloned).


Figure <ref> shows an example of a cloned graph by duplicating two nodes (in the original graph, left side, the set of nodes to be duplicated is highlighted).

    

        
    < g r a p h i c s >

    

    
        Clone of a graph by duplication
    
    


The next result indicates that duplicating positive nodes does not change the meaning of the queries.


    If WâŠ† V^+_Q, then Cl_Q^Wâ‰¡ Q.


	Let us denote Q_1 = Cl_Q^W. Then:
	
    Q_1    = â‹€_nâˆˆ V_Q_1Q_1_n^Î±(n)
    	 =â‹€_nâˆˆ V_QQ_1_n^Î±(n) âˆ§ â‹€_nâˆˆ WQ_1_n'^Î±(n')
       = â‹€_nâˆˆ V_Qâˆ–Î³_Q(W)Q_1_n^Î±(n) âˆ§ â‹€_nâˆˆÎ³_Q(W)Q_1_n^Î±(n) âˆ§ â‹€_nâˆˆ WQ_1_n'^Î±(n')
       = â‹€_nâˆˆ V_Qâˆ–Î³_Q(W) Q_n^Î±(n) âˆ§â‹€_nâˆˆÎ³_Q(W) Q_n^Î±(n) âˆ§ â‹€_nâˆˆ W Q_n^Î±(n)
       = Q



When refining a query to find complementary sets of selected subgraphs, we define the concept of a refinement set as central:


    Given Qâˆˆğ’¬, RâŠ†ğ’¬ is a refinement set of Q in G if:
    
        
  * âˆ€ Q'âˆˆ R (Q'â‰¼_G Q).
        
  * âˆ€ SâŠ† G (S Qâ‡’âˆƒ ! Q'âˆˆ R (S Q')).
    


Let us now introduce refinement sets to enhance simpler queries for expressiveness. Qâˆˆğ’¬ is prefixed, and âŠ¤ represents a tautology:

(Add new node)
    If mâˆ‰ V_Q, the set Q+{m}, formed by:
        
    Q_1    = (V_Qâˆª{m}, E_Q, Î±_Qâˆª(m,+), Î¸_Qâˆª(m,âŠ¤)) , 
     
             Q_2    = (V_Qâˆª{m}, E_Q, Î±_Qâˆª(m,-), Î¸_Qâˆª(m,âŠ¤))

    is a refinement set of Q in G (Fig. <ref>).


	We must verify the two necessary conditions for refinement sets:
	
		
  * Since QâŠ†^- Q_1 and QâŠ†^- Q_2, thus Q_1â‰¼ Q and Q_2â‰¼ Q.
		
  * Given SâŠ† G such that S Q. Then:
		
    Q_1   = Q âˆ§ Q_m ,
    
    		Q_2   = Q âˆ§  Q_m

		where Q_m=âˆƒ vâˆˆ V (âŠ¤).
		
		If Gâ‰ âˆ…, then S Q_1 and SâŠ­ Q_2.
		
		If G= âˆ…, then SâŠ­ Q_1 and S Q_2.
	


Since G â‰ âˆ… (usually), Q_1 â‰¡ Q. However, although we obtain an equivalent query, this operation is beneficial for adding new nodes and restrictions in the future.


    

        
    < g r a p h i c s >

    

    
        Add node refinement
    
    


The second refinement allows for the establishment of edges between query nodes that already exist. To obtain a valid refinement set, the inclusion of edges is limited to positive nodes. Subsequently, the nodes marked with a positive/negative sign represent cloned nodes whose Î± property has been designated as positive/negative.

(Add new edge between + nodes)
    If n,mâˆˆ V_Q^+, the set Q+{ne^*âŸ¶ m} (*âˆˆ{+,-}), formed by:
    
    Q_1    = (V_Q', E_Q'âˆª{n^+e^*âŸ¶ m^+}, Î¸_Q'âˆª(e,âŠ¤)), 
    
        Q_2    = (V_Q', E_Q'âˆª{n^+e^*âŸ¶ m^-}, Î¸_Q'âˆª(e,âŠ¤)), 
    
        Q_3    = (V_Q', E_Q'âˆª{n^-e^*âŸ¶ m^+}, Î¸_Q'âˆª(e,âŠ¤)), 
    
        Q_4    = (V_Q', E_Q'âˆª{n^-e^*âŸ¶ m^-}, Î¸_Q'âˆª(e,âŠ¤))

    (where Q'=Cl_Q^{n,m}) is a refinement set of Q in G (Fig. <ref>).


	  
		
  * Since Q' is a clone of Q, then Qâ‰¡ Q'. In addition,  Q'âŠ†^- Q_1,Q_2,Q_3,Q_4, thus Q_1,Q_2,Q_3,Q_4â‰¼ Q'â‰¡ Q.
		
  * Let us consider the predicates:
		
    P_n    = âˆƒ vâˆˆ V ( â‹€_aâˆˆÎ³(n) Q_a^Î±(a) âˆ§ Q_e^o^Î±(e)), 
    
    		P_m    = âˆƒ vâˆˆ V ( â‹€_aâˆˆÎ³(m) Q_a^Î±(a) âˆ§ Q_e^i^Î±(e)).

		If S Q_n and S Q_m, then we have four mutually complementary options:
		
			
  * S P_n âˆ§ S P_m â‡’ S Q_1
			
  * S P_n âˆ§ SâŠ­ P_m â‡’ S Q_2
			
  * SâŠ­ P_n âˆ§ S P_m â‡’ S Q_3
			
  * SâŠ­ P_n âˆ§ SâŠ­ P_m â‡’ S Q_4
		
	



    

        
    < g r a p h i c s >

    

    
        Add edge refinement (simplified)
    
    


Next, an additional predicate is added to an existing edge through the following operation, limited to positive edges connecting positive nodes.

(Add predicate to + edge between + nodes)
    If n,mâˆˆ V_Q^+, with ne^+âŸ¶ m, and Ï†âˆˆ Form^2(L), the set Q+{ne âˆ§Ï†âŸ¶ m}, formed by:
    
    Q_1    = (V_Q', E_Q'âˆª{n^+e'âŸ¶ m^+}, Î¸_Q'âˆª(e',Î¸_eâˆ§Ï†)), 
    
        Q_2    = (V_Q', E_Q'âˆª{n^+e'âŸ¶ m^-}, Î¸_Q'âˆª(e',Î¸_eâˆ§Ï†)), 
    
        Q_3    = (V_Q', E_Q'âˆª{n^-e'âŸ¶ m^+}, Î¸_Q'âˆª(e',Î¸_eâˆ§Ï†)), 
    
        Q_4    = (V_Q', E_Q'âˆª{n^-e'âŸ¶ m^-}, Î¸_Q'âˆª(e',Î¸_eâˆ§Ï†))

    (where Q'=Cl_Q^{n,m}) is a refinement set of Q in G (Fig. <ref>).


	The proof is similar to the previous ones.



    

        
    < g r a p h i c s >

    

    
	Add predicate to edge refinement (simplified)
    
    


Finally, the last step involves adding predicates to existing nodes. This operation is only permitted when the affected nodes are positive, including the node where the predicate is added and those connected to it.

(Add predicate to + node with + neighborhood)
    If Ï†âˆˆ Form^2(L), and nâˆˆ V_Q^+ with ğ’©_Q(n)âŠ† V_Q^+, then the set Q+{nâˆ§Ï†} formed by:
    
    {Q_Ïƒ=(V_Q',E_Q',Î±_Q'âˆªÏƒ,Î¸_Q'âˆª(n',Î¸_nâˆ§Ï†)) : Ïƒâˆˆ{+,-}^ğ’©_Q(n)}
 	
(where Q'=Cl_Q^ğ’©_Q(n), and {+,-}^ğ’©_Q(n) is the set of all possible assignments of signs to elements in ğ’©_Q(n))
is a refinement set of Q in G (Fig. <ref>).


	The proof resembles earlier ones. It is important to consider that modifying node n not only alters the associated predicate, but also those of its neighboring nodes. Additionally, the set of functions {+, -}^ğ’©_Q(n) encompasses all feasible sign assignments for the nodes within the neighborhood.



    

        
    < g r a p h i c s >

    

    
        Add predicate to node refinement (simplified)
    
    


Also note that simplified versions of the refinement sets are shown in Figures <ref>-<ref>. Section <ref> provides an explanation on how to obtain these simplifications.

Obtaining a complementary query from the structure is a challenging task. Nonetheless, graph analyses often require sequences of queries to verify properties related to refinement and complementarity. To bridge this gap, this section introduces refinement operations. These operations facilitate the construction of an embedded partition tree, where nodes are labelled as illustrated in Figure <ref>:


    
  * The root node is labeled with Q_0 (some initial query).
    
  * If a node on the tree is labelled with Q, and R={Q_1,â€¦,Q_n} is a set that refines Q, then the child nodes will be labelled with the elements of R.



    

        
    < g r a p h i c s >

    

    
        Refinements tree
    
    


Refinement sets presented herein offer one approach, rather than the sole approach. For example, we could consider refinements that, instead of adding constraints to positive elements, lighten the conditions over negative elements, for example, by using disjunction of predicates instead of conjunction of them.



 Â§.Â§ Simplified refinement sets


Let us simplify a query into an equivalent one by applying certain operations.


    We define Q'âŠ† Q as redundant in Q if Qâ‰¡ Q-Q'. Here, Q-Q' represents the subgraph of Q given by:
	
    (V_Qâˆ– V_Q', E_Qâˆ– (E_Q'âˆª{Î³(n): nâˆˆ V_Q'}),Î¼_Q)




One initial finding that enables the acquisition of simplified versions of a query by eliminating superfluous nodes is (from the following two results we only give an idea of the proof, which can be very laborious but straightforward from the above constructions):


	Given a query Q, and n,mâˆˆ V_Q verifying:
	
		
  * Î±(n)=Î±(m)
		
  * Î¸_nâ‰¡Î¸_m
		
  * For each eâˆˆÎ³(n), exists e'âˆˆÎ³(m), with Î±(e)=Î±(e'), Î¸_eâ‰¡Î¸_e' and Î³(e)âˆ–{n}=Î³(e')âˆ–{m}
	
	Then, n is redundant in Q.





A query Q comprises nodes and their relationships. Each query node imposes constraints on the subgraph that is evaluated, including the presence or absence of nodes and the paths in which they participate. These restrictions should be considered during the evaluation. If there are two nodes n,m âˆˆ V_Q with Î±(n) = Î±(m) and Î¸_nâ‰¡Î¸_m, and for each eâˆˆÎ³(n), there exists e'âˆˆÎ³(m), with Î±(e)=Î±(e'), Î¸_eâ‰¡Î¸_e' and Î³(e)âˆ–{n}=Î³(e')âˆ–{m}, both nodes apply identical restrictions to the subgraph being evaluated. Therefore, deleting one of them will not change the assessment on the subgraph.



Essentially, m is a duplicate of n, but potentially with additional connected edges. A comparable outcome for the edges can be achieved:


    Given a query Q, and two edges, e, e'âˆˆ E_Q, such that Î±(e)=Î±(e'), neâŸ¶ m and ne'âŸ¶ m with n,m âˆˆ V_Q^+. If Î¸_eâ†’Î¸_e' then e' is redundant in Q.





Following the same reasoning as the previous theorem, if there are two edges, e and e', in E_Q, which connect the same two nodes in a query and Î±(e)=Î±(e') and Î¸_eâ†’Î¸_e', the constraint imposed by e implies the constraint imposed by e'. Therefore, eliminating e' would maintain the set of matching subgraphs.



From these two findings, we can streamline the refinement sets that were established in section <ref> by removing redundant elements in succession after cloning. 



 Â§.Â§ Graph query examples


For illustrative purposes, this section presents a series of queries on a toy graph dataset. Figure <ref> illustrates a segment of the Starwars graph[http://console.neo4j.org/?id=StarWars].


    

        
    < g r a p h i c s >

    

    
        Section of Starwars Graph
    
    


To streamline query and graph representation, we will convert Ï„, a property denoting node and edge types, into labels for edges or icons for nodes. Additionally, the node properties denoted by name will be written on them, and the undirected edges will be represented by bidirectional arrows. The property Î± will be represented directly on query elements using + / - symbols, and we will write the binary predicate Î¸ directly on the elements (except for tautologies). When expressions such as Ï„ (Ï) = X are in the predicate of an edge, X is written directly and interpreted as a regular expression to be verified by the sequence of Ï„ properties of the links in the associated graph path. 


    

        
    < g r a p h i c s >

    

    
        Query 1
    
    


Query 1 (Figure <ref>) can be interpreted as follows: Two characters are connected by a TEACHES relationship, where the master is over 500 years old and both are devoted to the Jedi. This query utilizes structural constraints through the presence of edges and predicates with properties such as Ï„, name, and age. For example, in Figure <ref>, the subgraph comprising , , and their  relationship satisfies this query. 


    

        
    < g r a p h i c s >

    

    
      Query 2
    
    


Query 2 (Figure <ref>) outlines a cyclic query that utilises  relationships. It will be verified on any subgraph containing three characters who are friends with each other (for example, the subgraph formed by , ,  and the  relationships between them in Figure <ref>).


    

        
    < g r a p h i c s >

    

    
        Query 3
    
    


Query 3 (Figure <ref>) can be interpreted as follows: A character with more than 3 outgoing relationships, not belonging to the Sith clan, connected through a path consisting of any number of FRIENDS and TEACHES relationships with an individual from Alderaan. In this scenario, a regular expression has been employed to denote a path consisting of an unspecified amount of  and  relationships. Additionally, an auxiliary function, gr_s(v) âˆˆ L, has been utilised to reference the outgoing degree of node v. This query will be validated by any subgraph that contains  or .



 Â§.Â§ Computational complexity


Query systems based on graph isomorphisms (most of the existing ones) face NP-complete complexity  <cit.>.

The preceding section presented our graph query framework that is reliant on logical predicates. In this section, we will demonstrate that the assessment of queries is polynomial, even in the case of cyclic queries. This is achievable by imposing two constraints. First, the length of paths that are illustrated by links in the query is restricted by the constant k, and second, the complexity of the predicates used in nodes and edges is polynomial.

To verify S Q, it is necessary to examine each predicate Q_n(S) linked to all nodes n âˆˆ V_Q. Furthermore, each predicate Q_n(S) linked to a node in Q requires assessing one Q_e(v,S) predicate for every link eâˆˆÎ³_Q(n). Thus, initially, we shall focus on evaluating the computational complexity linked with the link predicates Q_e(v,S). Subsequently, we shall proceed to examine the complexity associated with the node predicates Q_n(S). Ultimately, we shall exhibit that the query complexity is polynomial.

As previously defined, the computational complexity of evaluating predicates attributed to both nodes and edges within a query Q is polynomial, denoted by ğ’ª(p). The predicates Q_e(v,S) related to edges in a query verify the existence of a path Ï in the graph G starting/ending in v that satisfies its own predicate Î¸_e (Ï, S) and with the source and destination nodes that satisfy the predicates Î¸_e^o (Ï^o , S) and Î¸_e^i (Ï^i , S) respectively. Thus, the complexity involved in evaluating a particular path is ğ’ª(3p) = ğ’ª(p). 

The computational complexity to verify the existence of a path beginning or ending at a node v in V, satisfying the aforementioned criteria, is ğ’ª(p Ã— |V|^k). Here, |V|^k denotes the number of paths that start or end at v under the condition that they are no longer than k in length. As the number of links commencing or ending at a node n âˆˆ V_Q is bound by |E_Q|, the computational complexity involved in the node predicate Q_n(S) is ğ’ª(pÃ— |V|^k Ã— |E_Q|). 

Finally, if the query consists of |V_Q| nodes, the complexity of checking the query Q(S) is ğ’ª(pÃ— |V|^k Ã— |E_Q| Ã— |V_Q|). It is evident that the constant k (path length bound) significantly impacts the execution of such queries, as it determines the exponent of the complexity.

Efficient operation of a graph query framework is crucial when dealing with large-scale data sets that are commonly found in real-world applications. Notably, when such a system is employed as the kernel of relational machine learning algorithms, as we will demonstrate in the following section, the ability to perform query operations in polynomial time, even for cyclic queries, is fundamental.
---------------------------fin chunk----------------
