In graph pattern matching, precise definitions are fundamental for research. They create a shared terminology, whilst theorems illustrated by mathematical proofs reveal essential characteristics and direct the development of algorithms. This paper presents a mathematical tool for conducting graph pattern matching. We will do this by utilising these mathematical tools.

We are exploring graph queries that enable atomic specialisations. We aim to produce pattern specialisations that select only a particular subset of elements by utilising a set of elements that satisfy a specific relational pattern. Selection Graphs serves as an instance of this query tool and has been developed for use in relational learning procedures. However, it has a fundamental limitation, as its patterns are unable to include cycles. Furthermore, when dealing with high relational data, incorporating a graphical representation of SQL queries can lead to efficiency issues. Our proposal draws inspiration from this method while bypassing its possible constraints.

When searching for query specialization, we aim to also create complementary queries to cover new conditions. Exploring the pattern space and characterizing elements in a top-down method would be helpful. In particular, we seek a group of specialized queries that create embedded partitions of a single query.

We would like to emphasise that our primary aim is to offer formalisation and examples of how the model can be applied, with the added goal of producing a real implementation that is practical for use\footnote{\url{https://github.com/palmagro/ggq}}.

Preliminaries

This passage presents preliminary concepts for defining graph queries. For a more complete review, refer to [2].

We will begin with a graph definition that encompasses several common types found in literature, such as directed/undirected graphs, multi-relational graphs, and hypergraphs. This definition serves as a foundational basis for general graph dataset structures and queries.

\begin{definition}
A Graph is a tuple G= (V, E, Î¼) where:

-  V and E are sets, called, respectively, set of nodes and set of edges of G.
-  Î¼ associates each node/edge in the graph with a set of properties Î¼: (V âˆª E) Ã— R â†’ J, where R represents the set of keys for properties, and J the set of values.

Furthermore, it is necessary to have a distinct key for the edges of the graph, called incidences and denoted by Î³, which associates each edge in E with a set of vertices in V.
\end{definition}
\medskip
The domain of Î¼ is the Cartesian product of the sets V âˆª E and R. Generally, we denote Î±(x) instead of Î¼(x,Î±) for each xâˆˆ Vâˆª E and Î± âˆˆ R, treating properties as maps from nodes/edges to values. Note that unlike standard definitions, the items in E are symbols that indicate the edges, rather than pairs of elements from V. Additionally, gamma is the function that matches each edge to the group of nodes, ordered or otherwise, that it connects.

We will use Î³(v) to denote the edges in which node vâˆˆ V participates. The neighbourhood of v is the set of nodes, including itself, connected to it, that is, ğ“(v)= â‹ƒ_{e âˆˆ Î³ (v)} Î³ (e).

For instance, we could depict a binary social graph G, which encompasses a set of nodes V, a set of edges E, and a function Î¼ that associates each node/edge in the graph with a set of properties R. Our social graph would comprise the attribute Ï„ âˆˆ R that may assume the values person and photo for the nodes and follows and like for edges. The attribute gamma âˆˆ R would be responsible for associating a pair of nodes in V with each edge. Furthermore, nodes and edges may possess additional attributes, such as age for nodes with Ï„= person or date for edges with Ï„= like.

We need to provide an understanding of the position of a node in an edge. We offer a basic definition of position, but a more comprehensive one can be provided to distinguish between directed and undirected edges:

\begin{definition}{}
If eâˆˆ E and Î³(e)=(vâ‚,\dots,vâ‚™)âˆˆ Vâ¿, then we define the position of each váµ¢âˆˆ Î³(e) in e as ordâ‚‘(váµ¢)=i. We denote u\leqâ‚‘ v to indicate ordâ‚‘(u)\leq ordâ‚‘(v).
\end{definition}

From this ordering of the nodes on an edge, we can establish paths within a graph.

\begin{definition}{}
Given a graph G=(V,E,Î¼), we define the set of paths in G as ğ“Ÿ_G, which is the smallest set that satisfies the conditions:

1. If eâˆˆ E and u, vâˆˆ Î³ (e) with u \leqâ‚‘ v, then Ï=u vâˆˆ ğ“Ÿ_G. We will say that Ï connects the nodes u and v of G, and we will denote it by u v.
2. If Ïâ‚, Ïâ‚‚âˆˆ ğ“Ÿ_G, with u v and v w then Ïâ‚Â·Ïâ‚‚ âˆˆ ğ“Ÿ_G, with u w.
\end{definition}\medskip

Some useful notations are as follows:

- If u v, then we write Ïáµ’=u and Ïâ±=v.
- We denote the paths through u, starting in u, and ending in u, respectively, by:
ğ“Ÿ_u(G)=\{Ï âˆˆ ğ“Ÿ(G): uâˆˆ Ï\},
ğ“Ÿ_u^o(G)=\{Ï âˆˆ ğ“Ÿ(G): Ï^o=u\},
ğ“Ÿ_u^i(G)=\{Ï âˆˆ ğ“Ÿ(G): Ï^i=u\}.
For example, for a graph G with V=\{vâ‚,vâ‚‚,vâ‚ƒ\} and E=\{eâ‚,eâ‚‚\}, Î³(eâ‚)= \{vâ‚,vâ‚‚\} and Î³(eâ‚‚)= \{vâ‚‚,vâ‚ƒ\}, the set of paths comprises ğ“Ÿ_G= \{ vâ‚ \stackrel{eâ‚}{â‡} vâ‚‚,vâ‚‚ \stackrel{e2}{â‡} vâ‚ƒ,vâ‚ \stackrel{e1Â· e2}{â‡} vâ‚ƒ\} with ğ“Ÿáµ’_{vâ‚}(G)=\{ vâ‚ \stackrel{e1}{â‡} vâ‚‚,vâ‚ \stackrel{e1Â· eâ‚‚}{â‡} vâ‚ƒ\} and ğ“Ÿâ±_{vâ‚}(G)=\emptyset.
The concept of a subgraph is acquired by employing the customary procedure of enforcing that the features are sustained within the intersecting elements.

\begin{definition}{}
A subgraph of G= (V, E,Î¼) is defined as a graph S= (V_S, E_S,Î¼_S) where V_S is a subset of V, E_S is a subset of E, and Î¼_S is a subset of Î¼_{|V_S âˆª E_S}. We denote S \subseteq G.
\end{definition}

An instance of a subgraph from the graph stated earlier could be constituted by V_S=\{vâ‚,vâ‚‚\}, E_S=\{eâ‚\}, and Î³{|V_S âˆª E_S}.

Graph queries

As mentioned previously, our graph query framework aims to enable the generation of complementary queries based on a given query. This entails ensuring that if a subgraph does not comply with a query, it must always comply with one of its complementaries. However, since projection hinders the evaluation of non-existent elements, which is necessary for achieving complementarity, we propose the use of logical predicates instead of projections.

In the following, we examine a graph that is prefixed, denoted by G=(V,E,Î¼). We will provide a brief formalization of our understanding of a predicate for G. More details on this topic can be found in [1].

Consider a collection of function, predicate, and constant symbols, called Î˜, which includes all the properties in Î¼, together with constants associated with elements of G, and possibly some additional symbols (for example, metrics defined in G, such as degree). We can use Î˜ as a set of non-logical symbols in the first-order language with equality, L. In this scenario, a predicate in G is an element of the set of first-order formulas of L (Form(L)). The binary predicates on G are indicated as FormÂ²(L).

\begin{definition}{}
A Query for G is a graph, specifically Q= (V_Q, E_Q, Î¼_Q), possessing Î± and Î¸ properties in Î¼_Q, and satisfying the following conditions:

- Î±:V_Qâˆª E_Qâ†’ \{+,-\}.
- Î¸:V_Qâˆª E_Qâ†’ FormÂ²(L).
\end{definition}\medskip

Formally, Q depends on L and G, but since we will consider L and G as prefixed, we will write Q âˆˆ ğ“  (instead of Q âˆˆ ğ“ (L, G) ) to denote that Q is a query on G using L. Note that once a query is defined, it can be applied to multiple graphs using the same language.

Intuitively, when examining a query, we utilize the second input of binary predicates to place limitations on the membership of subgraphs within G. Conversely, the first input should receive elements of the corresponding type with which it is associated.

For example, if a,bâˆˆ V_Q and eâˆˆ E_Q, and (we will denote Î¸â‚“:=Î¸(x)):

Î¸â‚(v,S)&:=vâˆˆ S,

Î¸_b(v,S)&:=âˆƒ zâˆˆ S (z \stackrel{}{â‡} v),

Î¸â‚‘(Ï,S)&:=âˆƒ y,z (y \stackrel{Ï}{â‡} z âˆ§ y âˆ‰ Sâˆ§ zâˆˆ S).

The node-based Î¸â‚(v,S) is defined to check whether the subgraph evaluation of S contains vâˆˆ V. The node-based Î¸_b(v,S) is verified only when a path in G connects a node of S with vâˆˆ G. Lastly, the path-based Î¸â‚‘(Ï,S) is defined to verify if the evaluated path Ïâˆˆ ğ“Ÿ_G connects S with its outward in G.

Given a query under the stated conditions, xâº (resp. xâ») is used to denote Î± (x)= + (resp. Î± (x)= - ), and V_Qâº/V_Qâ» (resp. E_Qâº/E_Qâ») represent the set of positive/negative nodes (resp. edges). If Î¸â‚“ is not explicitly defined for an element, it is assumed to be a tautology.

According to the following definition, positive elements impose constraints on the presence of queries, while negative elements impose constraints on their absence. To be more specific, each positive/negative node in a query requires the existence/non-existence of a node in G which satisfies its conditions (imposed by Î¸â‚“ and its edges):

\begin{definition}{}
Given S\subseteq G, and Qâˆˆ ğ“ , we say that S matches Q (S\vDash Q), if the following formula holds:

Q(S)=â‹€_{nâˆˆ V_Q} Q_n^{Î±(n)}(S)
where, for each node, nâˆˆ V_Q:
Q_n^+= Q_n,\hspace{1cm} Q_n^-= \neg Q_n,
Q_n(S)=âˆƒ vâˆˆ V (â‹€_{eâˆˆ Î³(n)} Q_{e^*}^{Î±(e)}(v,S)\right)
and, for each edge, eâˆˆ E_Q, *âˆˆ \{o,i\}:
Q_{e^*}^+= Q_{e^*}, Q_{e^*}^-= \neg Q_{e^*},

Q_{e^o}(v,S)=âˆƒ Ïâˆˆ ğ“Ÿ_v^o(G) (Î¸_e(Ï,S)âˆ§ Î¸_{e^o}(Ï^o,S) âˆ§ Î¸_{e^i}(Ï^i,S)\right),
Q_{e^i}(v,S)=âˆƒ Ïâˆˆ ğ“Ÿ_v^i(G) (Î¸_e(Ï,S)âˆ§ Î¸_{e^o}(Ï^o,S) âˆ§ Î¸_{e^i}(Ï^i,S)\right).

\end{definition}\medskip

A generic query example is shown in Figure 1.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{png/Fig1.pdf}
\end{center}
\caption{Graph Query Example}
\end{figure}

Unlike other previous graph query systems, this system can efficiently satisfy the following requirements: (1) the ability to contain cycles; (2) the capability to evaluate subgraphs; (3) projecting edges in the query onto paths in the graph; (4) evaluating structural and/or semantic characteristics; and (5) the added benefit of specialization through atomic operations (as will be discussed in the next section).

Refinement sets

To properly characterize the elements within a graph, it is crucial to utilize computationally effective methods when constructing queries based on basic operations. This section will introduce a query construction method optimized for use in relational learning tasks. To begin, let us first define the concept of relative refinements between queries.

\begin{definition}{}
Given Qâ‚, Qâ‚‚âˆˆ ğ“ , we say:

1. Qâ‚ refines Qâ‚‚ in G (Qâ‚\preceq_G Qâ‚‚) if:
âˆ€ S\subseteq G (S\vDash Qâ‚ â‡’ S\vDash Qâ‚‚).
2. They are equivalent in G (Qâ‚â‰¡_G Qâ‚‚) if:
Qâ‚\preceq_G Qâ‚‚ and Qâ‚‚\preceq_G Qâ‚.
\end{definition}\medskip

Two queries are deemed equivalent when they are confirmed to be exactly the same by identical subgraphs. From this definition, it is straightforward the following result is straightforward (the proof of which may be omitted):

\begin{theorem}{}
\preceq_G is a partial order in ğ“ . That is, for every Qâ‚, Qâ‚‚, Qâ‚ƒ âˆˆ ğ“ :

1. Qâ‚\preceq_G Qâ‚.
2. Qâ‚\preceq_G Qâ‚‚ âˆ§ Qâ‚‚\preceq_G Qâ‚ â‡’ Qâ‚â‰¡_G Qâ‚‚.
3. Qâ‚\preceq_G Qâ‚‚ âˆ§ Qâ‚‚\preceq_G Qâ‚ƒ â‡’ Qâ‚\preceq_G Qâ‚ƒ.
\end{theorem}\medskip

Next, we examine the relationship between the topological structure of a query and its functionality as a predicate on subgraphs. Generally, extracting logical properties of the predicate from the structural properties of the graph that represents it is difficult. However, we can obtain useful conditions to manipulate the structures and modify the query's semantics in a controlled manner.

\begin{definition}{}
Given Qâ‚, Qâ‚‚âˆˆğ“ , we say that Qâ‚ is a Qâ»-conservative extension of Qâ‚‚ (Qâ‚‚\subseteqâ» Qâ‚) if:

1. Qâ‚‚\subseteq Qâ‚.
2. âˆ€ nâˆˆ V_{Qâ‚‚}â»\, âˆ€ eâˆˆ Î³_{Qâ‚}(n)\, âˆƒ e'âˆˆ Î³_{Qâ‚‚}(n) (Qâ‚‘â‰¡ Q_{e'}).
\end{definition}\medskip

Figure 2 illustrates an example of a Qâ»-conservative extension. The novel element in the right query mandates fresh constraints on the positive node, but it does not introduce any additional constraints to the negative one.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{png/FIG2.pdf}
\end{center}
\caption{Qâ»-conservative extension}
\end{figure}

Since negative nodes introduce non-existence constraints to subgraph verification, Qâ»-conservative extensions guarantee that no new constraints are added to them. Therefore:

\begin{theorem}{}
If Qâ‚‚\subseteqâ» Qâ‚ then Qâ‚\preceq Qâ‚‚.
\end{theorem}
\begin{proof}{}
Since predicates associated to edges are solely based on the information within the edge itself (which takes into account the value of Î¸ in its incident nodes, irrespective of their Î± value), we can assert that:
âˆ€ eâˆˆ E_{Q_2} ({Q_1}_e^{Î±(e)}={Q_2}_e^{Î±(e)})

Considering this fact, we examine the behaviour of predicates associated with the nodes for both queries:

- If nâˆˆ V_Qâ‚‚â», since Qâ‚‚\subseteqâ» Qâ‚, then Qâ‚â‚™â»=Qâ‚‚â‚™â».
- If nâˆˆ V_Qâ‚‚âº, then Qâ‚â‚™âºâ†’ Qâ‚‚â‚™âº, because (Î³â‚, Î³â‚‚ are the incidence functions of Qâ‚ and Qâ‚‚, respectively):
â‚™âº &= âˆƒ vâˆˆ V ( â‹€_eâˆˆ Î³â‚(n) Qâ‚â‚‘^Î±(e)\right)
&= âˆƒ vâˆˆ V( â‹€_eâˆˆ Î³â‚(n)âˆ© E_Qâ‚‚ Qâ‚â‚‘^Î±(e) âˆ§ â‹€_eâˆˆ Î³â‚(n)âˆ– E_Qâ‚‚ Qâ‚â‚‘^Î±(e)\right)
&= âˆƒ vâˆˆ V( â‹€_eâˆˆ Î³â‚‚(n)âˆ© E_Qâ‚‚ Qâ‚‚â‚‘^Î±(e) âˆ§ â‹€_eâˆˆ Î³â‚(n)âˆ– E_Qâ‚‚ Qâ‚â‚‘^Î±(e)\right)
&â†’ Qâ‚‚â‚™âº

Hence:

Qâ‚ &= â‹€_{nâˆˆ V_{Qâ‚}} {Qâ‚}â‚™^{Î±(n)}= â‹€_{nâˆˆ V_{Qâ‚‚}} {Qâ‚}â‚™^{Î±(n)} âˆ§ â‹€_{nâˆˆ V_{Qâ‚}âˆ– V_{Qâ‚‚}} {Qâ‚}â‚™^{Î±(n)}

&= â‹€_{nâˆˆ V_{Qâ‚‚}âº} {Qâ‚}â‚™^{Î±(n)} âˆ§ â‹€_{nâˆˆ V_{Qâ‚‚}â»} {Qâ‚}â‚™^{Î±(n)} âˆ§ â‹€_{nâˆˆ V_{Qâ‚}âˆ– V_{Qâ‚‚}} {Qâ‚}â‚™^{Î±(n)}

&â†’ â‹€_{nâˆˆ V_{Qâ‚‚}âº} {Qâ‚‚}â‚™^{Î±(n)} âˆ§ â‹€_{nâˆˆ V_{Qâ‚‚}â»} {Qâ‚‚}â‚™^{Î±(n)} âˆ§ â‹€_{nâˆˆ V_{Qâ‚}âˆ– V_{Qâ‚‚}} {Qâ‚}â‚™^{Î±(n)}

&= â‹€_{nâˆˆ V_{Qâ‚‚}} {Qâ‚‚}â‚™^{Î±(n)} âˆ§ â‹€_{nâˆˆ V_{Qâ‚}âˆ– V_{Qâ‚‚}} {Qâ‚}â‚™^{Î±(n)}

&â†’ {Qâ‚‚}

\end{proof}
Previous result suggests that a query can be refined by adding nodes (of any sign) and edges to the existing positive nodes, but because of the (negated) interpretation of predicates associated with negative nodes, care must be taken to maintain their neighborhood to be sure that adding more edges does not weaken the imposed conditions (which consequently will not provide refined predicates).

To achieve controlled methods of query generation, we will outline processes for refining queries through unit steps. We shall accomplish this by defining the cloning operation, whereby existing nodes are duplicated, and all incident edges (including those between the nodes) on the original graph are also cloned:

\begin{definition}{}
Given G=(V,E,Î¼), and W\subseteq V, we define the clone of G by duplication of W, Cl_Gáµ‚, as:

Cl_G^W=(Vâˆª W',Eâˆª E',Î¼âˆª \{(n',Î¼(n))\}_{nâˆˆ W}âˆª \{(e',Î¼(e))\}_{e'âˆˆ E'})
where W'=\{n': nâˆˆ W\} are new cloned nodes from W, and E ' is a set of new edges obtained from incident edges on nodes of W where nodes of W are replaced by copies of W' (edges connecting original nodes with cloned nodes and edges connecting cloned nodes, are cloned).
\end{definition}\medskip

Figure 3 shows an example of a cloned graph by duplicating two nodes (in the original graph, left side, the set of nodes to be duplicated is highlighted).
\begin{figure}[h]
\begin{center}
\includegraphics[width=\columnwidth]{png/FIG3.pdf}
\end{center}
\caption{Clone of a graph by duplication}
\end{figure}

The next result indicates that duplicating positive nodes does not change the meaning of the queries.

\begin{theorem}{}
If W\subseteq Vâº_Q, then Cl_Qáµ‚â‰¡ Q.
\end{theorem}
\begin{proof}{}
Let us denote Qâ‚= Cl_Qáµ‚. Then:

Qâ‚ &= â‹€_{nâˆˆ V_{Qâ‚}} {Qâ‚}â‚™^{Î±(n)}
=â‹€_{nâˆˆ V_Q} {Qâ‚}â‚™^{Î±(n)} âˆ§ â‹€_{nâˆˆ W} {Qâ‚}_{n'}^{Î±(n')}

&= â‹€_{nâˆˆ V_Qâˆ– Î³_Q(W)} {Qâ‚}â‚™^{Î±(n)} âˆ§ â‹€_{nâˆˆÎ³_Q(W)} {Qâ‚}â‚™^{Î±(n)} âˆ§ â‹€_{nâˆˆ W} {Qâ‚}_{n'}^{Î±(n')}

&= â‹€_{nâˆˆ V_Qâˆ– Î³_Q(W)} Qâ‚™^{Î±(n)} âˆ§ â‹€_{nâˆˆÎ³_Q(W)} Qâ‚™^{Î±(n)} âˆ§ â‹€_{nâˆˆ W} Qâ‚™^{Î±(n)}

&= Q

\end{proof}

When refining a query to find complementary sets of selected subgraphs, we define the concept of a refinement set as central:

\begin{definition}{}
Given Qâˆˆ ğ“ , R\subseteq ğ“  is a refinement set of Q in G if:

1. âˆ€ Q'âˆˆ R (Q'\preceq_G Q).
2. âˆ€ S\subseteq G (S\vDash Qâ‡’ âˆƒ! Q'âˆˆ R (S\vDash Q')).
\end{definition}\medskip

Let us now introduce refinement sets to enhance simpler queries for expressiveness. Qâˆˆğ“  is prefixed, and âŠ¤ represents a tautology:

\begin{theorem}{(Add new node)}
If mâˆ‰ V_Q, the set Q+\{m\}, formed by:

Qâ‚ &= (V_Qâˆª\{m\}, E_Q, Î±_Qâˆª(m,+), Î¸_Qâˆª(m,âŠ¤)),

Qâ‚‚ &= (V_Qâˆª\{m\}, E_Q, Î±_Qâˆª(m,-), Î¸_Qâˆª(m,âŠ¤))

is a refinement set of Q in G (Fig. 4).
\end{theorem}
\begin{proof}{}
We must verify the two necessary conditions for refinement sets:

1. Since Q\subseteqâ» Qâ‚ and Q\subseteqâ» Qâ‚‚, thus Qâ‚\preceq Q and Qâ‚‚\preceq Q.
2. Given S\subseteq G such that S\vDash Q. Then:

Qâ‚&= Q âˆ§ Qâ‚˜,
Qâ‚‚&= Q âˆ§ \neg Qâ‚˜

where Qâ‚˜=âˆƒ vâˆˆ V (âŠ¤).
If G\neq \emptyset, then S\vDash Qâ‚ and S\nvDash Qâ‚‚.
If G= \emptyset, then S\nvDash Qâ‚ and S\vDash Qâ‚‚.
\end{proof}

Since G \neq \emptyset (usually), Qâ‚ â‰¡ Q. However, although we obtain an equivalent query, this operation is beneficial for adding new nodes and restrictions in the future.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{png/REF1.pdf}
\end{center}
\caption{Add node refinement}
\end{figure}

The second refinement allows for the establishment of edges between query nodes that already exist. To obtain a valid refinement set, the inclusion of edges is limited to positive nodes. Subsequently, the nodes marked with a positive/negative sign represent cloned nodes whose Î± property has been designated as positive/negative.

\begin{theorem}{(Add new edge between + nodes)}
If n,mâˆˆ V_Qâº, the set Q+\{n\stackrel {e^*}{âŸ¶} m\} (*âˆˆ\{+,-\}), formed by:

Qâ‚ &= (V_{Q'}, E_{Q'}âˆª\{nâº\stackrel {e^*}{âŸ¶} mâº\}, Î¸_{Q'}âˆª(e,âŠ¤)),

Qâ‚‚ &= (V_{Q'}, E_{Q'}âˆª\{nâº\stackrel {e^*}{âŸ¶} mâ»\}, Î¸_{Q'}âˆª(e,âŠ¤)),

Qâ‚ƒ &= (V_{Q'}, E_{Q'}âˆª\{nâ»\stackrel {e^*}{âŸ¶} mâº\}, Î¸_{Q'}âˆª(e,âŠ¤)),

Qâ‚„ &= (V_{Q'}, E_{Q'}âˆª\{nâ»\stackrel {e^*}{âŸ¶} mâ»\}, Î¸_{Q'}âˆª(e,âŠ¤))

(where Q'=Cl_Q^{\{n,m\}}) is a refinement set of Q in G (Fig. 5).
\end{theorem}
\begin{proof}{}
\quad

1. Since Q' is a clone of Q, then Qâ‰¡ Q'. In addition, Q'\subseteqâ» Qâ‚,Qâ‚‚,Qâ‚ƒ,Qâ‚„, thus Qâ‚,Qâ‚‚,Qâ‚ƒ,Qâ‚„\preceq Q'â‰¡ Q.
2. Let us consider the predicates:

Pâ‚™ &= âˆƒ vâˆˆ V ( â‹€_aâˆˆ Î³(n) Qâ‚^Î±(a) âˆ§ Q_eáµ’^Î±(e)\right),
Pâ‚˜ &= âˆƒ vâˆˆ V ( â‹€_aâˆˆ Î³(m) Qâ‚^Î±(a) âˆ§ Q_eâ±^Î±(e)\right).

If S\vDash Qâ‚™ and S\vDash Qâ‚˜, then we have four mutually complementary options:
   â€¢ S\vDash Pâ‚™ âˆ§ S\vDash Pâ‚˜ â‡’ S\vDash Qâ‚
   â€¢ S\vDash Pâ‚™ âˆ§ S\nvDash Pâ‚˜ â‡’ S\vDash Qâ‚‚
   â€¢ S\nvDash Pâ‚™ âˆ§ S\vDash Pâ‚˜ â‡’ S\vDash Qâ‚ƒ
   â€¢ S\nvDash Pâ‚™ âˆ§ S\nvDash Pâ‚˜ â‡’ S\vDash Qâ‚„
\end{proof}

\begin{figure}[h]
\begin{center}
\includegraphics[width=\columnwidth]{png/REF2SIM.pdf}
\end{center}
\caption{Add edge refinement (simplified)}
\end{figure}

Next, an additional predicate is added to an existing edge through the following operation, limited to positive edges connecting positive nodes.

\begin{theorem}{(Add predicate to + edge between + nodes)}
If n,mâˆˆ V_Qâº, with n\stackrel {eâº}{âŸ¶} m, and ğœ‘âˆˆ FormÂ²(L), the set Q+\{n\stackrel {e âˆ§ ğœ‘}{âŸ¶} m\}, formed by:

Qâ‚ &= (V_{Q'}, E_{Q'}âˆª\{nâº\stackrel {e'}{âŸ¶} mâº\}, Î¸_{Q'}âˆª(e',Î¸â‚‘âˆ§ ğœ‘)),

Qâ‚‚ &= (V_{Q'}, E_{Q'}âˆª\{nâº\stackrel {e'}{âŸ¶} mâ»\}, Î¸_{Q'}âˆª(e',Î¸â‚‘âˆ§ ğœ‘)),

Qâ‚ƒ &= (V_{Q'}, E_{Q'}âˆª\{nâ»\stackrel {e'}{âŸ¶} mâº\}, Î¸_{Q'}âˆª(e',Î¸â‚‘âˆ§ ğœ‘)),

Qâ‚„ &= (V_{Q'}, E_{Q'}âˆª\{nâ»\stackrel {e'}{âŸ¶} mâ»\}, Î¸_{Q'}âˆª(e',Î¸â‚‘âˆ§ ğœ‘))

(where Q'=Cl_Q^{\{n,m\}}) is a refinement set of Q in G (Fig. 6).
\end{theorem}
\begin{proof}{}
The proof is similar to the previous ones.
\end{proof}

\begin{figure}[h]
\begin{center}
\includegraphics[width=\columnwidth]{png/REF3SIM.pdf}
\end{center}
\caption{Add predicate to edge refinement (simplified)}
\end{figure}

Finally, the last step involves adding predicates to existing nodes. This operation is only permitted when the affected nodes are positive, including the node where the predicate is added and those connected to it.

\begin{theorem}{(Add predicate to + node with + neighborhood)}
If ğœ‘âˆˆ FormÂ²(L), and nâˆˆ V_Qâº with ğ“_Q(n)\subseteq V_Qâº, then the set Q+\{nâˆ§ ğœ‘\} formed by:
\{Q_{Ïƒ}=(V_{Q'},E_{Q'},Î±_{Q'}âˆª Ïƒ,Î¸_{Q'}âˆª(n',Î¸_nâˆ§ğœ‘)): Ïƒâˆˆ \{+,-\}^{ğ“_Q(n)}\}
(where Q'=Cl_Q^{ğ“_Q(n)}, and \{+,-\}^{ğ“_Q(n)} is the set of all possible assignments of signs to elements in ğ“_Q(n))
is a refinement set of Q in G (Fig. 7).
\end{theorem}
\normalsize
\begin{proof}{}
The proof resembles earlier ones. It is important to consider that modifying node n not only alters the associated predicate, but also those of its neighboring nodes. Additionally, the set of functions \{+, -\}^{ğ“_Q(n)} encompasses all feasible sign assignments for the nodes within the neighborhood.
\end{proof}

\begin{figure}[h]
\begin{center}
\includegraphics[width=\columnwidth]{png/REF4SIM.pdf}
\end{center}
\caption{Add predicate to node refinement (simplified)}
\end{figure}

Also note that simplified versions of the refinement sets are shown in Figures 4-7. Section 8 provides an explanation on how to obtain these simplifications.

Obtaining a complementary query from the structure is a challenging task. Nonetheless, graph analyses often require sequences of queries to verify properties related to refinement and complementarity. To bridge this gap, this section introduces refinement operations. These operations facilitate the construction of an embedded partition tree, where nodes are labelled as illustrated in Figure 9:

- The root node is labeled with Qâ‚€ (some initial query).
- If a node on the tree is labelled with Q, and R=\{Qâ‚,\dots,Qâ‚™\} is a set that refines Q, then the child nodes will be labelled with the elements of R.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{png/FIG4.pdf}
\end{center}
\caption{Refinements tree}
\end{figure}

Refinement sets presented herein offer one approach, rather than the sole approach. For example, we could consider refinements that, instead of adding constraints to positive elements, lighten the conditions over negative elements, for example, by using disjunction of predicates instead of conjunction of them.

Simplified refinement sets

Let us simplify a query into an equivalent one by applying certain operations.

\begin{definition}{}
We define Q'\subseteq Q as redundant in Q if Qâ‰¡ Q-Q'. Here, Q-Q' represents the subgraph of Q given by:
(V_Qâˆ– V_{Q'}, E_Qâˆ– (E_{Q'}âˆª\{Î³(n): nâˆˆ V_{Q'}\}),Î¼_Q)

\end{definition}\medskip

One initial finding that enables the acquisition of simplified versions of a query by eliminating superfluous nodes is (from the following two results we only give an idea of the proof, which can be very laborious but straightforward from the above constructions):

\begin{theorem}{}
Given a query Q, and n,mâˆˆ V_Q verifying:

- Î±(n)=Î±(m)
- Î¸â‚™â‰¡Î¸â‚˜
- For each eâˆˆ Î³(n), exists e'âˆˆ Î³(m), with Î±(e)=Î±(e'), Î¸â‚‘â‰¡Î¸_{e'} and Î³(e)âˆ–\{n\}=Î³(e')âˆ–\{m\}
Then, n is redundant in Q.
\end{theorem}

\begin{proof}{}

A query Q comprises nodes and their relationships. Each query node imposes constraints on the subgraph that is evaluated, including the presence or absence of nodes and the paths in which they participate. These restrictions should be considered during the evaluation. If there are two nodes n,m âˆˆ V_Q with Î±(n)= Î±(m) and Î¸â‚™â‰¡Î¸â‚˜, and for each eâˆˆ Î³(n), there exists e'âˆˆ Î³(m), with Î±(e)=Î±(e'), Î¸â‚‘â‰¡Î¸_{e'} and Î³(e)âˆ–\{n\}=Î³(e')âˆ–\{m\}, both nodes apply identical restrictions to the subgraph being evaluated. Therefore, deleting one of them will not change the assessment on the subgraph.
\end{proof}

Essentially, m is a duplicate of n, but potentially with additional connected edges. A comparable outcome for the edges can be achieved:

\begin{theorem}{}
Given a query Q, and two edges, e, e'âˆˆ E_Q, such that Î±(e)=Î±(e'), n\stackrel {e}{âŸ¶} m and n\stackrel {e'}{âŸ¶} m with n,m âˆˆ V_Qâº. If Î¸â‚‘â†’ Î¸_{e'} then e' is redundant in Q.
\end{theorem}

\begin{proof}{}

Following the same reasoning as the previous theorem, if there are two edges, e and e', in E_Q, which connect the same two nodes in a query and Î±(e)=Î±(e') and Î¸â‚‘â†’ Î¸_{e'}, the constraint imposed by e implies the constraint imposed by e'. Therefore, eliminating e' would maintain the set of matching subgraphs.

\end{proof}

From these two findings, we can streamline the refinement sets that were established in section 10 by removing redundant elements in succession after cloning.

Graph query examples

For illustrative purposes, this section presents a series of queries on a toy graph dataset. Figure 11 illustrates a segment of the Starwars graph\footnote{http://console.neo4j.org/?id=StarWars}.

\begin{figure}[h!]
\begin{center}
\includegraphics[width=\columnwidth]{png/FIG5.pdf}
\end{center}
\caption{Section of Starwars Graph}
\end{figure}

To streamline query and graph representation, we will convert Ï„, a property denoting node and edge types, into labels for edges or icons for nodes. Additionally, the node properties denoted by name will be written on them, and the undirected edges will be represented by bidirectional arrows. The property Î± will be represented directly on query elements using + / - symbols, and we will write the binary predicate Î¸ directly on the elements (except for tautologies). When expressions such as Ï„ (Ï)= X are in the predicate of an edge, X is written directly and interpreted as a regular expression to be verified by the sequence of Ï„ properties of the links in the associated graph path.

\begin{figure}[h!]
\begin{center}
\includegraphics[width=\columnwidth]{png/PQG1.pdf}
\end{center}
\caption{Query 1}
\end{figure}

Query 1 (Figure 12) can be interpreted as follows: Two characters are connected by a TEACHES relationship, where the master is over 500 years old and both are devoted to the Jedi. This query utilizes structural constraints through the presence of edges and predicates with properties such as Ï„, name, and age. For example, in Figure 11, the subgraph comprising Yoda, Luke, and their TEACHES relationship satisfies this query.

\begin{figure}[h]
\begin{center}
\includegraphics[width=\columnwidth]{png/PQG3.pdf}
\end{center}
\caption{Query 2}
\end{figure}

Query 2 (Figure 13) outlines a cyclic query that utilises FRIENDS relationships. It will be verified on any subgraph containing three characters who are friends with each other (for example, the subgraph formed by Hans Solo, Chewbaka, Princess Leia and the FRIENDS relationships between them in Figure 11).

\begin{figure}[h]
\begin{center}
\includegraphics[width=\columnwidth]{png/PQG4.pdf}
\end{center}
\caption{Query 3}
\end{figure}

Query 3 (Figure 14) can be interpreted as follows: A character with more than 3 outgoing relationships, not belonging to the Sith clan, connected through a path consisting of any number of FRIENDS and TEACHES relationships with an individual from Alderaan. In this scenario, a regular expression has been employed to denote a path consisting of an unspecified amount of FRIENDS and TEACHES relationships. Additionally, an auxiliary function, grâ‚›(v) âˆˆ L, has been utilised to reference the outgoing degree of node v. This query will be validated by any subgraph that contains Luke or Obi Wan Kenobi.

Computational complexity

Query systems based on graph isomorphisms (most of the existing ones) face NP-complete complexity [3, 4].

The preceding section presented our graph query framework that is reliant on logical predicates. In this section, we will demonstrate that the assessment of queries is polynomial, even in the case of cyclic queries. This is achievable by imposing two constraints. First, the length of paths that are illustrated by links in the query is restricted by the constant k, and second, the complexity of the predicates used in nodes and edges is polynomial.

To verify SâŠ§ Q, it is necessary to examine each predicate Qâ‚™(S) linked to all nodes n âˆˆ V_Q. Furthermore, each predicate Qâ‚™(S) linked to a node in Q requires assessing one Qâ‚‘(v,S) predicate for every link eâˆˆÎ³_Q(n). Thus, initially, we shall focus on evaluating the computational complexity linked with the link predicates Qâ‚‘(v,S). Subsequently, we shall proceed to examine the complexity associated with the node predicates Qâ‚™(S). Ultimately, we shall exhibit that the query complexity is polynomial.

As previously defined, the computational complexity of evaluating predicates attributed to both nodes and edges within a query Q is polynomial, denoted by ğ“(p). The predicates Qâ‚‘(v,S) related to edges in a query verify the existence of a path Ï in the graph G starting/ending in v that satisfies its own predicate Î¸â‚‘ (Ï, S) and with the source and destination nodes that satisfy the predicates Î¸_{eáµ’} (Ïáµ’, S) and Î¸_{eâ±} (Ïâ±, S) respectively. Thus, the complexity involved in evaluating a particular path is ğ“(3p)= ğ“(p).

The computational complexity to verify the existence of a path beginning or ending at a node v in V, satisfying the aforementioned criteria, is ğ“(p Ã— |V|áµ). Here, |V|áµ denotes the number of paths that start or end at v under the condition that they are no longer than k in length. As the number of links commencing or ending at a node n âˆˆ V_Q is bound by |E_Q|, the computational complexity involved in the node predicate Qâ‚™(S) is ğ“(pÃ— |V|áµ Ã— |E_Q|).

Finally, if the query consists of |V_Q| nodes, the complexity of checking the query Q(S) is ğ“(pÃ— |V|áµ Ã— |E_Q| Ã— |V_Q|). It is evident that the constant k (path length bound) significantly impacts the execution of such queries, as it determines the exponent of the complexity.

Efficient operation of a graph query framework is crucial when dealing with large-scale data sets that are commonly found in real-world applications. Notably, when such a system is employed as the kernel of relational machine learning algorithms, as we will demonstrate in the following section, the ability to perform query operations in polynomial time, even for cyclic queries, is fundamental.